// /composables/useChat.ts
import { createClient, SupabaseClient, RealtimeChannel } from '@supabase/supabase-js'
import { useRuntimeConfig } from '#app'
import { ref, reactive, computed, onMounted, onUnmounted } from 'vue'

type Conversation = {
  id: string
  kind: 'dm' | 'group' | 'system'
  title: string | null
  created_at: string
}

type ParticipantRow = {
  conversation_id: string
  user_id: string
  last_read_at: string | null
  conversation?: Conversation
}

type Message = {
  id: string
  conversation_id: string
  sender_id: string | null
  body: string | null
  attachment_url: string | null
  attachment_meta: any | null
  created_at: string
}

let _sb: SupabaseClient | null = null
function sb() {
  if (_sb) return _sb
  const { public: pub } = useRuntimeConfig()
  _sb = createClient(pub.supabaseUrl, pub.supabaseAnonKey, {
    auth: { persistSession: true, autoRefreshToken: true }
  })
  return _sb
}

export function useChat() {
  const supabase = sb()

  // state
  const conversations = ref<Conversation[]>([])
  const activeId = ref<string | null>(null)
  const messages = ref<Message[]>([])
  const loading = ref(false)
  const uploading = ref(false)

  // unread tracking
  const myUserId = ref<string | null>(null)
  const lastReadByConv = reactive<Record<string, string | null>>({})
  const unreadCounts = reactive<Record<string, number>>({})
  const totalUnread = computed(() =>
    Object.values(unreadCounts).reduce((a, b) => a + (b || 0), 0)
  )

  // surface errors for UI if you want to show a banner
  const lastError = ref<string | null>(null)

  // computed
  const currentMessages = computed(() => messages.value)

  // realtime channels
  let activeConvChannel: RealtimeChannel | null = null
  let inboxChannel: RealtimeChannel | null = null

  /** Make sure we know who we are */
  async function ensureUser() {
    if (myUserId.value) return myUserId.value
    const { data, error } = await supabase.auth.getUser()
    if (error) {
      console.error('auth.getUser failed:', error.message)
      lastError.value = error.message
      return null
    }
    myUserId.value = data.user?.id || null
    return myUserId.value
  }

  function requireAuth() {
    if (!myUserId.value) {
      const msg = 'You must be signed in to use chat.'
      lastError.value = msg
      throw new Error(msg)
    }
  }

  /** Load conversations the current user participates in (robust against conversation RLS) */
  async function loadConversations() {
    loading.value = true
    lastError.value = null
    await ensureUser()

    if (!myUserId.value) {
      // anonymous user -> nothing to load
      conversations.value = []
      loading.value = false
      return
    }

    // Fetch via participants so we only get convos the user is in.
    // Also grab last_read_at here.
    const { data, error } = await supabase
      .from('conversation_participants')
      .select(`
        conversation_id,
        user_id,
        last_read_at,
        conversation:conversations ( id, kind, title, created_at )
      `)
      .eq('user_id', myUserId.value)
      .order('conversation(created_at)', { ascending: false })

    if (error) {
      loading.value = false
      lastError.value = error.message
      throw new Error(error.message)
    }

    const rows = (data || []) as (ParticipantRow & { conversation: Conversation })[]
    // map conversations
    conversations.value = rows
      .map(r => r.conversation)
      .filter(Boolean) as Conversation[]

    // cache last_read_at
    for (const r of rows) {
      lastReadByConv[r.conversation_id] = r.last_read_at ?? null
    }
    for (const c of conversations.value) {
      if (!(c.id in lastReadByConv)) lastReadByConv[c.id] = null
    }

    // prime unread counts
    await Promise.all(conversations.value.map(c => refreshUnreadFor(c.id)))

    // global inbox realtime (new messages anywhere)
    attachInboxRealtime()

    loading.value = false
  }

  /** Listen to new messages (RLS must be enabled; Supabase Realtime respects RLS) */
  function attachInboxRealtime() {
    if (inboxChannel) supabase.removeChannel(inboxChannel)
    inboxChannel = supabase
      .channel('chat:inbox')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'messages' },
        async payload => {
          const m = payload.new as Message
          // ignore my own messages
          if (m.sender_id && myUserId.value && m.sender_id === myUserId.value) return

          // if it's the active conversation, append it
          if (activeId.value === m.conversation_id) {
            messages.value = [...messages.value, m]
            return
          }

          // otherwise bump unread if newer than last_read_at
          const last = lastReadByConv[m.conversation_id]
          if (!last || new Date(m.created_at).getTime() > new Date(last).getTime()) {
            unreadCounts[m.conversation_id] = (unreadCounts[m.conversation_id] || 0) + 1
          }
        }
      )
      .subscribe()
  }

  /** Open a conversation (load history, realtime, mark read) */
  async function openConversation(id: string) {
    activeId.value = id
    lastError.value = null

    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', id)
      .order('created_at', { ascending: true })
      .limit(1000)

    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }

    messages.value = (data || []) as Message[]

    // live for this conversation
    if (activeConvChannel) supabase.removeChannel(activeConvChannel)
    activeConvChannel = supabase
      .channel(`chat:conv:${id}`)
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'messages', filter: `conversation_id=eq.${id}` },
        payload => {
          const m = payload.new as Message
          messages.value = [...messages.value, m]
        }
      )
      .subscribe()

    // mark as read
    await markConversationRead(id)
  }

  /** Mark as read (upsert participant row to be safe) */
  async function markConversationRead(conversationId: string) {
    await ensureUser()
    requireAuth()

    const nowIso = new Date().toISOString()
    const { error } = await supabase
      .from('conversation_participants')
      .upsert(
        { conversation_id: conversationId, user_id: myUserId.value, last_read_at: nowIso },
        { onConflict: 'conversation_id,user_id' }
      )

    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }

    lastReadByConv[conversationId] = nowIso
    unreadCounts[conversationId] = 0
  }

  /** Server-count unread (excludes my own messages) */
  async function refreshUnreadFor(conversationId: string) {
    await ensureUser()
    if (!myUserId.value) { unreadCounts[conversationId] = 0; return }

    const last = lastReadByConv[conversationId]
    let q = supabase
      .from('messages')
      .select('id', { count: 'exact', head: true })
      .eq('conversation_id', conversationId)
      .neq('sender_id', myUserId.value)

    if (last) q = q.gt('created_at', last)

    const { count, error } = await q
    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }
    unreadCounts[conversationId] = count || 0
  }

  /** Send text message */
  async function sendMessage(body: string) {
    if (!activeId.value || !body.trim()) return
    await ensureUser()
    requireAuth()

    const { error } = await supabase.from('messages').insert({
      conversation_id: activeId.value,
      sender_id: myUserId.value,
      body
    })

    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }

    await markConversationRead(activeId.value)
  }

  /** Upload an attachment and send */
  async function sendAttachment(file: File) {
    if (!activeId.value) return
    await ensureUser()
    requireAuth()

    uploading.value = true
    try {
      const path = `${myUserId.value}/${activeId.value}/${Date.now()}_${file.name}`
      const { error: upErr } = await supabase.storage
        .from('chat-uploads')
        .upload(path, file, { cacheControl: '3600', upsert: false })
      if (upErr) throw upErr

      const { data: signed, error: signErr } = await supabase
        .storage.from('chat-uploads')
        .createSignedUrl(path, 60 * 60)
      if (signErr) throw signErr

      const { error: msgErr } = await supabase.from('messages').insert({
        conversation_id: activeId.value,
        sender_id: myUserId.value,
        body: null,
        attachment_url: signed.signedUrl,
        attachment_meta: { name: file.name, size: file.size, type: file.type, storage_path: path }
      })
      if (msgErr) throw msgErr

      await markConversationRead(activeId.value)
    } catch (e: any) {
      lastError.value = e?.message ?? String(e)
      throw e
    } finally {
      uploading.value = false
    }
  }

  /** Forward a message to another conversation */
  async function forwardMessage(messageId: string, targetConversationId: string) {
    await ensureUser()
    requireAuth()

    const msg = messages.value.find(m => m.id === messageId)
    if (!msg) return

    const payload: Partial<Message> & { conversation_id: string } = {
      conversation_id: targetConversationId,
      sender_id: myUserId.value,
      body: msg.body ? `Forwarded:\n${msg.body}` : null
    }

    if (msg.attachment_meta?.storage_path) {
      const { data: signed, error: signErr } = await supabase
        .storage.from('chat-uploads')
        .createSignedUrl(msg.attachment_meta.storage_path, 60 * 60)
      if (!signErr && signed?.signedUrl) {
        payload.attachment_url = signed.signedUrl
        payload.attachment_meta = msg.attachment_meta
      }
    }

    const { error } = await supabase.from('messages').insert(payload)
    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }

    await refreshUnreadFor(targetConversationId)
  }

  /** Start a new conversation (creates participant row and opens it) */
  async function startConversation(kind: 'dm' | 'group' = 'group', title = 'New Chat') {
    await ensureUser()
    requireAuth()

    // NOTE: created_by is set by DB trigger if you added it per my earlier instructions
    const { data, error } = await supabase
      .from('conversations')
      .insert({ kind, title })
      .select('id, kind, title, created_at')
      .single()

    if (error) {
      lastError.value = error.message
      throw new Error(error.message)
    }

    // upsert participant for me (and timestamp read now)
    const nowIso = new Date().toISOString()
    const { error: pErr } = await supabase
      .from('conversation_participants')
      .upsert(
        { conversation_id: data.id, user_id: myUserId.value, last_read_at: nowIso },
        { onConflict: 'conversation_id,user_id' }
      )
    if (pErr) {
      lastError.value = pErr.message
      throw new Error(pErr.message)
    }

    // keep local list updated (top)
    conversations.value = [data as Conversation, ...conversations.value]
    lastReadByConv[data.id] = nowIso
    unreadCounts[data.id] = 0

    await openConversation(data.id)
    return data.id
  }

  /** Alias */
  async function setActive(id: string) {
    return await openConversation(id)
  }

  /** Optional: deep link helper */
  function buildMessageDeepLink(messageId: string) {
    const origin = typeof window !== 'undefined' ? window.location.origin : 'https://xplor.io'
    return `${origin}/chat/c/${activeId.value}?m=${messageId}`
  }

  onMounted(async () => {
    await ensureUser()
  })

  onUnmounted(() => {
    if (activeConvChannel) supabase.removeChannel(activeConvChannel)
    if (inboxChannel) supabase.removeChannel(inboxChannel)
  })

  return {
    // state
    conversations,
    activeId,
    messages,
    currentMessages,
    loading,
    uploading,
    myUserId,
    lastError,
    // unread
    unreadCounts,
    totalUnread,
    // core actions
    loadConversations,
    openConversation,
    setActive,
    startConversation,
    sendMessage,
    sendAttachment,
    forwardMessage,
    buildMessageDeepLink,
    // read helpers
    markConversationRead,
    refreshUnreadFor,
  }
}
